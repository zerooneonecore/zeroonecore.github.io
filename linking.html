<!DOCTYPE html>
<html>
<head>
<style>
  body {background-color: #121212;
        color: white;}
  h1 { text-align: center; }
  h2 { text-align: center; }
  #code_1 { border: 2px solid white; width: 50%; margin: auto; padding: 2px;text-align: center;}
  #code_2 { border: 2px solid red; }
  .source { border: 2px solid white; width: 50%; margin: auto; padding: 4px; text-align: center;}
 


</style>
<body>
  <h1>linking, maybe loading</h1><br>
  <br>
  <p>So, back to the drawing board, I wanted a modular way of modifying programs for purposes of instrumentation,
    and knew that it would amount to editing a <i>section</i>. Though, this seemed to present its own problems,
    because its one thing to patch an instruction on an already compiled executable, its another to add new
    instructions, it might mean that every other address or relocation information past that line would
    need to be adjusted. <br>This was better than recompiling the entire program, but it certainly didn't 
    appear elegant. This suggested that the right tool for the job was breakpoints, and debuggers, and that
    perhaps its wiser to work within memory. So there must be an elegant way to intercept functions using
    debuggers, with breakpoints being the obvious primitive.
    <p class="source">
      (gdb) p/t *(long int *)0x7fffffffde18<br>
           $66 = 10101010101010100000000000000000000000000010100<br>
      (gdb) p/t *(long int*)$rbp-0x18<br>
           $67 = 11111111111111111111111111111111101111000111000<br>
      (gdb) p $rbp-0x18 == 0x7fffffffde18<br>
    </p>
  I am mystified as to why these two commands give different results, casting should not changed the binary
  representation, only the amount of bits shown? 
  </p>
  </body>
  </html>
