
<!DOCTYPE html>
<html>
<head>
<style>
  body {background-color: #121212;
        color: white;}
  h1 { text-align: center; }
  #code_1 { border: 2px solid white; width: 50%; margin: auto; padding: 2px;text-align: center;}
  #code_2 { border: 2px solid red; }
  .source { border: 2px solid white; width: 50%; margin: auto; padding: 4px; text-align: center; overflow: scroll;}
 


</style>
<body>
  <h1>machinas's 'Twiddling'</h1><br>
  <p>
  So the author provides a hint which is that this crackme somehow relates to 'bit twiddling', or working with bits.
  The author has just riddled this binary with function calls of various taunting names. I wasn't having
  the best of luck finding the success function, so I decided to just start understanding the code from
  the beginning. What is rather interesting however, is that the author implemented a parser, albeit a simple
  one, but a parser rather than just asking for the flag in a commandline argument. So far so good with the
  data flow of the program.
  <br><br><p class="source">
  (gdb) x $rdi<br>
  0x7fffffffde10:	102 'f'<br>
  (gdb) x $rdi+1<br>
  0x7fffffffde11:	108 'l'<br>
  (gdb) x $rdi+2<br>
  0x7fffffffde12:	97 'a'<br>
  </p><br><br>
  This is the data that would be read by the <i>stod()</i> function call to follow. the stod function would
  then read the user input itself, shown following
  <br><br><p class="source">
  (gdb) x $rdi+1<br>
0x7fffffffde11:	65 'A'<br>
(gdb) x $rdi+2<br>
0x7fffffffde12:	65 'A'<br>
(gdb) x $rdi+3<br>
0x7fffffffde13:	65 'A'<br>
(gdb) x $rdi+4
0x7fffffffde14:	10 '\n'<br>
  </p><br><br>
  So far as I can tell, all <i>stod()</i> does is read the string. After the call to <i>strlen()</i>, the program
  compares the string length with 0x20=32, presumably for the benefit of the bit twiddling routines to come?
  So the string definitely needs to be 31 characters long excluding newline.  
  
  </p>
  
    
    
  </body>
  </html>
