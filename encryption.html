<!DOCTYPE html>
<html>
<head>
<style>
  body {background-color: #121212;
        color: white;}
  h1 { text-align: center; }
  #code_1 { border: 2px solid red; }
  #code_2 { border: 2px solid red; }

</style>
<body>
<h1>Rudimentary Encryption</h1>
<p>Encryption is the means to obfuscate data, but also to recover it.<br>
   A rudimentary form of encryption is the bitwise exclusive or, or "XOR" operation,
   bitwise meaning that it operates on bits. an odd number of truth values is true,
   and an even number is false. There are a couple of interesting features of xor,
   on their own.<br>For instance A xor A is all zeros, and A xor !A or ("not A") is all ones.<br>
   Hence, an encryption scheme can use the bitwise negation, to actually encrypt the data,
  and there exists a way to recover the data, since<br> <i>((A xor !A) xor !A) == A</i>,
   If this were implemented as a runtime decryption routine, "reverse engineering" it would depend on recognizing
   the bitwise negation, and xor instructions.<br>Some details of note, if we were encrypting the string
   within the executable, the bitwise xor with bitwise NOT could be used within the compilation of the program, as such
   the instructions to look for are the xor operation, for example<br>
   Suppose (A xor !A) is stored within the readonly data section, let this equal C, then the runtime decryption
   routine is C xor E, where presumably E or C are either !A or (A xor !A). For this reason xor signifies
   that an encryption/decryption routine is under execution. It would be interesting to know if there
   were equivalents to xor, which might be harder to see when reverse engineering a program.<br>
   The equation <i>((A xor !A) xor !A) == A</i> can be demonstrated with the following c code,
   <br><strong>char * A = "elppa\n";</strong<br>
   <strong>printf("%c\n", ((*(A) ^ ~(*(A))) ^ ~(*(A))));</strong><br>
   This can be decomposed as per, we have a string, and we dereference the first byte with <i>*(A)</i>,
  <i>*</i> is the dereference operator, and A is the argument. So the bitwise negation of A, is the NOT
   of the first byte, which is *(A), NOTTED, which becomes ~(*(A)), we xor these two together, using
   paranthesis to ensure we do this first, and then bitwise xor this again with the NOT of A, what will 
  be printed is the original first character, 'e'
  
  
     


  
  </p>
   
   
 
</body>
</html>
